/**
 ******************************************************************************
 * @file    nextion_driver.c
 * @author  Generated by audit tool
 * @brief   Nextion HMI Driver Implementation (Improved ACK handling)
 * @date    2025
 ******************************************************************************
 */

#include "nextion_driver.h"
#include "usart.h"
#include <string.h>
#include <stdio.h>
// Add IWDG to allow refresh during waits
#include "iwdg.h"

/* Private defines -----------------------------------------------------------*/
#define NEXTION_END_STRING "\xFF\xFF\xFF"
#define NEXTION_TIMEOUT_MS 100

/* Private variables ---------------------------------------------------------*/
static char nextion_buffer[128];

/* Shared ACK state (defined once here, declared extern in usart.h) ----------*/
volatile uint8_t waiting_for_ack = 0;
volatile uint8_t ack_code = 0;

/* Function implementations --------------------------------------------------*/

/**
 * @brief Send a command to the Nextion display
 * @param command Command string to send
 */
void NEXTION_SendCommand(const char* command)
{
	if (command == NULL) return;

	// Prepare command into local TX buffer with terminators (handle overlap safely)
	// Reserve 3 bytes for 0xFF terminators
	size_t cmd_len = strlen(command);
	if (cmd_len > (sizeof(nextion_buffer) - 4)) {
		cmd_len = sizeof(nextion_buffer) - 4;
	}
	memmove(nextion_buffer, command, cmd_len);
	nextion_buffer[cmd_len] = '\0';
	// Append 3x 0xFF (no C-string terminator needed for TX)
	nextion_buffer[cmd_len + 0] = 0xFF;
	nextion_buffer[cmd_len + 1] = 0xFF;
	nextion_buffer[cmd_len + 2] = 0xFF;
	size_t tx_len = cmd_len + 3;

	// Request an ACK and send via UART1 (non-blocking receive handled in ISR)
	waiting_for_ack = 1;
	ack_code = 0;
	HAL_UART_Transmit(&huart1, (uint8_t*)nextion_buffer, tx_len, NEXTION_TIMEOUT_MS);

	// Wait for acknowledgment (short timeout)
	NEXTION_WaitForACK();
}

/**
 * @brief Wait for ACK from Nextion display without starving the IWDG.
 *        Avoid HAL_GetTick (broken) by using DWT CYCCNT when available,
 *        otherwise fall back to a bounded loop. Refresh IWDG periodically.
 */
void NEXTION_WaitForACK(void)
{
	// If ISR already processed the ACK, return early
	if (waiting_for_ack == 0) {
		(void)ack_code;
		return;
	}

	// Setup DWT cycle counter for an accurate timeout when available
	uint8_t use_dwt = 0;
#if defined(DWT) && defined(CoreDebug) && defined(DWT_CTRL_CYCCNTENA_Msk)
	// Enable DWT CYCCNT if not already enabled
	if ((CoreDebug->DEMCR & CoreDebug_DEMCR_TRCENA_Msk) == 0) {
		CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
	}
	if ((DWT->CTRL & DWT_CTRL_CYCCNTENA_Msk) == 0) {
		DWT->CYCCNT = 0; // reset counter
		DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
	}
	uint32_t start = DWT->CYCCNT;
	// Quick sanity that CYCCNT increments
	__NOP();
	uint32_t after = DWT->CYCCNT;
	if (after != start) {
		use_dwt = 1;
	}
	// Compute timeout in CPU cycles (SystemCoreClock cycles per second)
	uint32_t timeout_cycles = (uint32_t)((SystemCoreClock / 1000U) * (uint32_t)NEXTION_TIMEOUT_MS);
#endif

	// Fallback loop budget if DWT not usable (empirical)
	// Choose a budget roughly proportional to clock; base 800k at 48 MHz ~100ms
	uint32_t fallback_budget = (SystemCoreClock > 0U) ? (SystemCoreClock / 60U) : 800000U;
	if (fallback_budget < 5000U) fallback_budget = 5000U; // minimum spins

	// Main wait loop
	while (waiting_for_ack != 0) {
		// Refresh the watchdog to prevent reset while waiting
		HAL_IWDG_Refresh(&hiwdg);

#if defined(DWT) && defined(CoreDebug) && defined(DWT_CTRL_CYCCNTENA_Msk)
		if (use_dwt) {
			uint32_t now = DWT->CYCCNT;
			if ((uint32_t)(now - start) >= timeout_cycles) {
				break; // timeout
			}
		} else
#endif
		{
			// Fallback: decrement loop budget and timeout when exhausted
			if (fallback_budget-- == 0U) {
				break; // timeout
			}
		}

		// Hint to CPU: light delay to reduce tight spin without sleeping
		__NOP();
	}

	// Do not forcefully clear waiting_for_ack; leave ISR as source of truth.
	// ack_code may be used by caller later; consume/ignore for now.
	(void)ack_code;
}

/**
 * @brief Set text of a Nextion object
 * @param object_name Name of the object
 * @param text Text to set
 */
void NEXTION_SetText(const char* object_name, const char* text)
{
	if (object_name == NULL || text == NULL) return;

	snprintf(nextion_buffer, sizeof(nextion_buffer), "%s.txt=\"%s\"", object_name, text);
	NEXTION_SendCommand(nextion_buffer);
}

/**
 * @brief Set value of a Nextion object
 * @param object_name Name of the object
 * @param value Value to set
 */
void NEXTION_SetValue(const char* object_name, int value)
{
	if (object_name == NULL) return;

	snprintf(nextion_buffer, sizeof(nextion_buffer), "%s.val=%d", object_name, value);
	NEXTION_SendCommand(nextion_buffer);
}

/**
 * @brief Set background color of a Nextion object
 * @param object_name Name of the object
 * @param color Color value (16-bit RGB565)
 */
void NEXTION_SetBackgroundColor(const char* object_name, uint32_t color)
{
	if (object_name == NULL) return;

	snprintf(nextion_buffer, sizeof(nextion_buffer), "%s.bco=%u", object_name, (unsigned int)color);
	NEXTION_SendCommand(nextion_buffer);
}

/**
 * @brief Set picture of a Nextion object
 * @param object_name Name of the object
 * @param pic_id Picture ID
 */
void NEXTION_SetPicture(const char* object_name, int pic_id)
{
	if (object_name == NULL) return;

	snprintf(nextion_buffer, sizeof(nextion_buffer), "%s.pic=%d", object_name, pic_id);
	NEXTION_SendCommand(nextion_buffer);
}

/**
 * @brief Change to a specific page
 * @param page Page number
 */
void NEXTION_ChangePage(uint8_t page)
{
	snprintf(nextion_buffer, sizeof(nextion_buffer), "page %d", page);
	NEXTION_SendCommand(nextion_buffer);
}

/**
 * @brief Set text color of a Nextion object
 * @param object_name Name of the object
 * @param color Color value (16-bit RGB565)
 */
void NEXTION_SetTextColor(const char* object_name, uint16_t color)
{
	if (object_name == NULL) return;

	snprintf(nextion_buffer, sizeof(nextion_buffer), "%s.pco=%u", object_name, (unsigned int)color);
	NEXTION_SendCommand(nextion_buffer);
}

/**
 * @brief Set visibility of a Nextion object
 * @param object_name Name of the object
 * @param visible 1 to show, 0 to hide
 */
void NEXTION_SetVisible(const char* object_name, uint8_t visible)
{
	if (object_name == NULL) return;
	unsigned int v = (visible != 0U) ? 1U : 0U;
	snprintf(nextion_buffer, sizeof(nextion_buffer), "vis %s,%u", object_name, v);
	NEXTION_SendCommand(nextion_buffer);
}

/**
 * @brief Request the value of a Nextion object (<obj>.val)
 *        The ISR will deliver the payload via SubghzApp_UART_RxDone.
 * @param object_name Name of the object
 */
void NEXTION_GetValue(const char* object_name)
{
	if (object_name == NULL) return;

	snprintf(nextion_buffer, sizeof(nextion_buffer), "get %s.val", object_name);
	NEXTION_SendCommand(nextion_buffer);
}

/**
 * @brief Clear the screen with a specific color
 * @param color Color value (16-bit RGB565)
 */
void NEXTION_ClearScreen(uint16_t color)
{
	snprintf(nextion_buffer, sizeof(nextion_buffer), "cls %u", (unsigned int)color);
	NEXTION_SendCommand(nextion_buffer);
}